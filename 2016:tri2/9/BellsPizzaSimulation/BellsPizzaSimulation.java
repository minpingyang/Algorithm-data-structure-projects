// This program is copyright VUW.
// You are granted permission to use it to construct your answer to a COMP103 assignment.
// You may not distribute it in any other way without permission.

/* Code for COMP 103, Assignment 8
 * Name:
 * Usercode:
 * ID:
 */
import java.util.*;
import java.io.*;

/**
 * Simulates the pizza delivery aspect of the BellsPizza business.
 * 
 * Reads pizza delivery requests from log files. 
 * The latter have been generated by class "MakeLog".
 * 
 * Note that all log file require 45min of pure delivery, i.e., 
 * no further pizza requests during the last 45min.
 *
 * @author Thomas Kuehne (based on existing code).
 * 
 */
public class BellsPizzaSimulation {
    // map from destinations to the delivery times they imply
    private Map<String, Integer> destinationToCostMap = new HashMap<String, Integer>();
    //private HeapArrayQueue<E> 

    /**
     * Constructs a new BellsPizzaSimulation object and
     * loads in destinations that the company delivers to (including delivery times).
     */
    public BellsPizzaSimulation() {
        loadDestinations();
    }

    /**
     * Loads in destinations and delivery times from file 'destinations.txt'.
     * 
     */
    private void loadDestinations() {
        try {
            Scanner sc = new Scanner(new File("destinations.txt"));

            while (sc.hasNext()) {
                destinationToCostMap.put(sc.next(), (int)(sc.nextInt()));    
            }

        }
        catch(IOException e) {System.out.println("Reading from destination file failed: "+e);}
    }

    /**
     * Reads a single pizza request from the log file, and returns a corresponding Pizza object. 
     * 
     * @returns a pizza object, or 'null' if there was no pizza request for this time
     */
    private Pizza readPizza(int currentTime, Scanner logFile) {
        String status = logFile.next();

        // is there no pizza request at this time?
        if (status.equals("-"))
            return null;

        // read status; the status is either "standard" or "urgent"
        boolean urgent = status.equals("urgent");  

        // read destination
        String destination = logFile.next();

        // obtain delivery time
        int deliveryTime = destinationToCostMap.get(destination);

        // create corresponding pizza object
        return new Pizza(destination, deliveryTime, currentTime, urgent);
    }

    /**
     * Runs through each of the log files and compares the performance between the 
     * standard queue and the priority queue solutions. 
     * 
     * For the COMPLETION stage, you need to change the value of variable 'fname'
     * from "log"+i to "completLog..."i.
     * 
     * Each log file is used to simulate handling a sequence of pizza orders over
     * time. For each log file, the simulation is first run with an ordinary queue 
     * (using a standard linked list from the Java collections library), and then your 
     * HeapArrayQueue. 
     * 
     * For the CHALLENGE stage, you should uncomment the code that also uses the HeapLinkedQueue as well.
     */
    private void runTests() {
        try {
            for (int i = 1; i<=20; i++) { 

                // compose file name; change this to "completLog"+i for the COMPLETION stage
                String fname= "completLog"+i;
                // String fname= "log"+i;
                System.out.println("======================= Log File: "+ fname + " =======================");
                System.out.print("StandardQueue:  ");
                double profitQueue = run(new LinkedList<Pizza>(), new Scanner(new File(fname)));

                System.out.print("PriorityQueue:  ");
                double profitPQueue = run(new HeapArrayQueue<Pizza>(), new Scanner(new File(fname)));

                System.out.printf("                                                                          Saving = $%4.2f\n", profitPQueue-profitQueue);

                /*#         CHALLENGE STAGE  
                 * uncomment the following to include your HeapLinkedQueue
                 */

                //         System.out.print("ChallengeQueue: ");
                //         double profitLinkedPQueue = run(new HeapLinkedQueue<Pizza>(), new Scanner(new File(fname)));
                // 
                //         System.out.printf("                                                                          Saving = $%4.2f\n", profitLinkedPQueue-profitQueue);
            }
        } catch (IOException e) {System.out.println("Opening log file failed: "+e);}
    } 

    /**
     * Returns the profit (if positive, or loss if negatigve) of handling
     * the pizza orders contained in the log file, using the queue provided
     * by the runTests() method above.
     */
    private double run (Queue<Pizza> queue, Scanner logFile) {
        double total = 0;                     // profit tally

        int countOnTime = 0;            // how many pizzas were delivered on time
        int countLateStandard = 0;      // how many standard pizzas were delivered late
        int countLateUrgent = 0;        // how many urgent pizzas were delivered late
        int countUndelivered = 0;       // how many pizzas remained undelivered 

        /*# COMPLETION STAGE 
         * add the management of more cyclists to this method
         */
        int numberOfcyclists=3;
        //three different available Time
        int [] cyclistAvailableTimes= new int[numberOfcyclists];

        int cyclistAvailableAt = 0;     // the time when the cyclist will next be available.
        int time = 0;                   // global time
       

        // as long as there are still minutes to process in the log file...
        while (logFile.hasNext()) {
            // read next time stamp
            time = logFile.nextInt();
            // read pizza order (if any) belonging to this time stamp
            Pizza pizza = this.readPizza(time, logFile);
            // was there an order?
            if (pizza != null) {
                // yes, record it 
                queue.offer(pizza);
                // update profit tally
                total += pizza.price() - Pizza.HandlingCost;
            }
             int availableCyclist=0;
             
            //three of cyclists the inital available simulation time is 0
            // once find one of their available time < current time
            //then ask the cyclist to delivery the pizza
           
            for(int i=0;i<cyclistAvailableTimes.length;i++){
                if(cyclistAvailableTimes[i]<time){
                    availableCyclist=i;
                    break;
                }
            }
             // if there is not cyclist available time < current time,
             // then cant go into the below if statement to delevery this pizza
             
            // if a cyclist (and a pizza) is available then let them deliver the next pizza from the queue
            if (time>cyclistAvailableTimes[availableCyclist]&& !queue.isEmpty()) {

                // obtain next pizza from the queue
                Pizza deliveredPizza = queue.poll();
        
                // is it impossible to deliver this pizza on time?
                if (time + deliveredPizza.deliveryTime() > deliveredPizza.deadline()) {

                    // refund the pizza price with a penalty factor applied
                    total -= deliveredPizza.latePrice();

                    // update the late pizza counts
                    if (deliveredPizza.isUrgent()) 
                        countLateUrgent++;
                    else 
                        countLateStandard++; 

                } else  // delivery on time was possible
                    countOnTime++;

                // calculate busy time for cyclist
                int fullTripTime = 2 * deliveredPizza.deliveryTime();  

                // calculate when the cyclist will be available again.
                //cyclistAvailableAt=time + fullTripTime;
               
                //update this cyclist's avaliable time in the array of times 
                cyclistAvailableTimes[availableCyclist]=time + fullTripTime;               

                // update profit tally with delivery cost
                total -= Pizza.PerMinuteDeliveryCost * fullTripTime;
            }

        }

        logFile.close();

        // after even the last 45 'no orders'-minutes of the log file have elapsed
        // every pizza remaining the queue is considered to be 'undelivered'.
        while(!queue.isEmpty()) {
            Pizza undeliveredPizza = queue.poll();

            // undelivered pizzas are counted as 'late' pizzas
            total -= undeliveredPizza.latePrice(); 
            countUndelivered++;
        }

        // report statistics on the whole simulation
        System.out.printf("on time: %2d, late:%2d (urgent=%2d, std=%2d, undelivered=%2d), Profit: $%4.2f\n",
            countOnTime, (countLateUrgent+countLateStandard+countUndelivered),
            countLateUrgent, countLateStandard, countUndelivered, total);
        return total;
    }

    // run the Bells Pizza simu
    public static void main(String[] arguments) {
        BellsPizzaSimulation bellsPizza = new BellsPizzaSimulation();
        bellsPizza.runTests();
    } 
}
